# 🎬 V2.0 测试指南 - 基于 Codex 方案

## ✨ V2.0 新特性

### 核心改进
1. **GraphQL API 拦截** - 自动捕获 Twitter API 响应，获取真实媒体URL
2. **页面状态解析** - 读取 `__INITIAL_STATE__` 和 `__APOLLO_STATE__`
3. **智能媒体选择** - 自动选择最高质量（MP4 优先，最高 bitrate）
4. **浏览器端 HLS 处理** - 无需 ffmpeg，直接在浏览器中合并分片
5. **DOM 后备方案** - 如果 API 拦截失败，仍可从 DOM 提取

### 技术亮点
- ✅ 不再依赖 ffmpeg
- ✅ 不再有 Blob URL 问题
- ✅ 支持 Master Playlist（自动选择最高码率）
- ✅ 支持 Media Playlist（合并 .m4s 分片）
- ✅ 递归查找所有 tweet 对象（支持复杂嵌套）
- ✅ 在浏览器端完成所有视频处理

## 🚀 测试步骤

### 第1步：启动服务器

```bash
cd E:\gitpromts
node server.js
```

应该看到：
```
🚀 Server running at http://localhost:3000
```

### 第2步：重新加载扩展

1. 打开 Chrome，访问 `chrome://extensions/`
2. 找到 "X 推文收藏助手"
3. 点击 **刷新按钮** (🔄)
4. 确认扩展已启用

### 第3步：测试 GraphQL 拦截

1. 访问 Twitter/X 主页：https://x.com

2. 打开开发者工具（F12）

3. 刷新页面，应该看到以下日志：
   ```
   📚 X 推文收藏助手 v2.0 已加载
   🔌 Twitter API 拦截器已注入
   ✅ Twitter API 拦截器已启动
   ```

4. 滚动页面，当推文加载时应该看到：
   ```
   📡 拦截到 GraphQL 响应: https://x.com/i/api/graphql/...
   💾 缓存媒体数据: 1985362073115885908 {images: [...], videos: [...]}
   ```

5. 检查缓存：
   ```javascript
   // 在控制台执行
   console.log(window.__twitterMediaData);
   ```
   应该显示一个 Map，包含各个推文的媒体数据

### 第4步：测试视频采集（MP4 直链）

1. 找一个包含视频的推文（通常 Twitter 提供 MP4 直链）

2. 点击推文下方的 **📚 采集** 按钮

3. 观察控制台输出：
   ```
   📝 提取结果: {
     title: "...",
     tweetId: "1234567890",
     images: 0,
     videos: 1,
     videoDetails: [{
       url: "https://video.twimg.com/.../xxx.mp4",
       type: "mp4",
       bitrate: 2176000,
       contentType: "video/mp4"
     }]
   }
   📤 开始采集推文: ...
   ```

4. 编辑页面应该自动打开，视频URL 应该是 MP4 直链

### 第5步：测试 HLS 视频

1. 访问测试推文：
   ```
   https://x.com/LTXStudio/status/1985362073115885908
   ```

2. 等待推文加载，检查控制台：
   ```
   💾 缓存媒体数据: 1985362073115885908 {
     images: [],
     videos: [{
       url: "https://video.twimg.com/.../xxx.m3u8",
       type: "hls",
       contentType: "application/x-mpegURL"
     }]
   }
   ```

3. 点击 **📚 采集** 按钮

4. 按钮应该变为 **🎬 处理中...**

5. 观察控制台，应该看到详细的 HLS 处理过程：
   ```
   📤 开始采集推文: ...
   🎬 处理 HLS 视频 1...
   🎬 开始处理 HLS: https://video.twimg.com/.../xxx.m3u8
   📄 Playlist 内容: #EXTM3U...
   📋 检测到 Master Playlist，选择最高码率...
   ✅ 选择变体: https://video.twimg.com/.../1280x720/xxx.m3u8
   📄 Playlist 内容: #EXTM3U...
   📦 找到 150 个分片
   ⬇️ 下载 init segment...
   ⬇️ 下载分片 1/150...
   ⬇️ 下载分片 2/150...
   ⏳ 进度: 1%
   ⏳ 进度: 2%
   ...
   ⏳ 进度: 100%
   🔗 合并分片...
   ✅ HLS 处理完成，大小: 15.23 MB
   ✅ HLS 视频上传成功: tweet-1985362073115885908-0.mp4
   ```

6. 服务器控制台应该显示：
   ```
   ✅ 视频上传成功: tweet-1985362073115885908-0.mp4 (15.23 MB)
   ```

7. 检查 `E:\gitpromts\videos\` 目录，应该有新的 MP4 文件

### 第6步：验证文件

1. 打开 `E:\gitpromts\videos\` 目录

2. 找到新下载的视频文件，例如：
   ```
   tweet-1985362073115885908-0.mp4
   ```

3. 用播放器打开，确认视频可以正常播放

## 🔍 调试技巧

### 检查缓存数据

```javascript
// 查看所有缓存的媒体数据
console.log('缓存:', window.__twitterMediaData);

// 查看所有 API 响应
console.log('API 响应:', window.__twitterApiResponses);

// 查看特定推文的媒体
const tweetId = '1985362073115885908';
console.log('推文媒体:', window.__twitterMediaData.get(tweetId));
```

### 检查当前推文

```javascript
// 获取当前页面所有推文
const tweets = document.querySelectorAll('article[data-testid="tweet"]');
console.log('推文数量:', tweets.length);

// 查看第一个推文的媒体
const firstTweet = tweets[0];
const timeElement = firstTweet.querySelector('time');
const link = timeElement?.closest('a');
const tweetUrl = link ? 'https://x.com' + link.getAttribute('href') : null;
const tweetId = tweetUrl?.match(/status\/(\d+)/)?.[1];
console.log('推文 ID:', tweetId);
console.log('推文媒体:', window.__twitterMediaData.get(tweetId));
```

### 手动触发媒体提取

```javascript
// 如果发现某个推文没有提取到媒体，可以尝试手动提取
// 复制并执行以下代码（需要在页面上下文中）

function manualExtract() {
  const tweets = document.querySelectorAll('article[data-testid="tweet"]');
  tweets.forEach((tweet, index) => {
    const timeElement = tweet.querySelector('time');
    const link = timeElement?.closest('a');
    const tweetUrl = link ? 'https://x.com' + link.getAttribute('href') : null;
    const tweetId = tweetUrl?.match(/status\/(\d+)/)?.[1];

    if (tweetId) {
      console.log(`推文 ${index + 1} (ID: ${tweetId}):`,
        window.__twitterMediaData.get(tweetId) || '无缓存数据');
    }
  });
}

manualExtract();
```

## ⚠️ 常见问题

### Q1: 控制台没有显示 "拦截到 GraphQL 响应"
**原因**：页面脚本注入失败，或页面已经加载完成
**解决**：
1. 刷新页面
2. 重新加载扩展
3. 检查浏览器的 Content Security Policy (CSP)

### Q2: 缓存中没有视频数据
**原因**：
- Twitter 的某些推文可能不通过 GraphQL 加载
- 推文可能是嵌入的或引用的
**解决**：
1. 点击进入推文详情页
2. 等待推文完全加载
3. 视频开始播放后再采集

### Q3: HLS 下载很慢
**原因**：视频由 100+ 个分片组成，需要逐个下载
**优化**：可以修改代码实现并发下载（但要注意不要触发速率限制）

### Q4: 视频下载失败 (CORS 错误)
**原因**：Twitter 的视频服务器可能有 CORS 限制
**解决**：这不应该发生，因为我们是在页面上下文中下载的。如果出现，检查：
1. 是否使用了 VPN/代理
2. 浏览器是否有特殊的安全设置

### Q5: 视频无法播放
**原因**：
- 合并的分片可能不完整
- MIME type 不正确
**解决**：
1. 检查控制台是否有错误
2. 确认所有分片都下载成功
3. 尝试用 VLC 等强大的播放器打开

## 📊 性能指标

### 预期性能
- **GraphQL 拦截延迟**：< 50ms
- **MP4 直链采集**：即时（秒级）
- **HLS 处理时间**：取决于视频长度
  - 30秒视频 (~50 分片)：10-20 秒
  - 1分钟视频 (~100 分片)：20-40 秒
  - 2分钟视频 (~200 分片)：40-80 秒

### 网络使用
- 每个分片通常 100-200 KB
- 1 分钟视频约 10-20 MB
- 所有下载都在浏览器中完成，不经过服务器

## 🎯 下一步优化

1. **并发下载** - 同时下载多个分片（提速 5-10 倍）
2. **进度显示** - 在 UI 上显示下载进度
3. **缓存管理** - 定期清理旧的缓存数据
4. **错误重试** - 分片下载失败时自动重试
5. **质量选择** - 让用户选择视频质量（而不是总是最高）

---

**版本**: v2.0
**日期**: 2025-11-05
**基于**: Codex 验证方案
